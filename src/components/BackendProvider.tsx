import {Accessor, createContext, createSignal, onCleanup, onMount, ParentComponent, useContext} from "solid-js";
import {createStore, SetStoreFunction} from "solid-js/store";
import {parsedPackets, pushParsedPackets} from "../backend_interop/buffers";
import {
    PacketStructureViewModel,
    Packet, //for inserting fake packets when testing graphs
    SerialUpdateResult as SerialUpdateResult,
    SerialPortNames,
    PacketStructureViewModelUpdate,
    PacketStructureViewModelUpdateType,
    SendingLoopState
} from "../backend_interop/types";
import {emit, listen, UnlistenFn} from "@tauri-apps/api/event";

/**
 * The global state managed by the {@link BackendContext}.
 */
export type BackendContextValue = {
    /**
     * An accessor to get the name information for each available serial port that can be connected to.
     */
    availablePortNames: Accessor<SerialPortNames[]>,
    /**
     * An accessor to get the number of packets parsed.
     */
    parsedPacketCount: Accessor<number>,
    /**
     * The list of registered {@link PacketStructureViewModel}s for each `PacketStructure`.
     */
    PacketStructureViewModels: PacketStructureViewModel[],

    setPacketStructureViewModels: SetStoreFunction<PacketStructureViewModel[]>,

    /**
     * Information about the current or most recent sending loop task.
     * Will be null before an update is received.
     */
    sendingLoopState: Accessor<SendingLoopState | null>
};

/**
 * The context that holds the global {@link BackendContextValue}.
 */
const BackendContext = createContext<BackendContextValue>({
    availablePortNames: (): SerialPortNames[] => [],
    parsedPacketCount: () => 0,
    PacketStructureViewModels: [],
    setPacketStructureViewModels: () => {},
    sendingLoopState: () => null
});

//for inserting fake packets
//let iterator = 1;

/**
 * A component that abstracts interactions with the Rust backend by providing a context containing a view into
 * backend-managed state.
 *
 * @param props the children to provide backend-managed state to
 * @returns a component wrapping the given child component that provides a context to access backend-managed state
 * @see {@link BackendContextValue} for the global view into the backend-managed state provided by this component
 */
export const BackendProvider: ParentComponent = (props) => {
    const [availablePortNames, setAvailablePortNames] = createSignal<SerialPortNames[]>([]);
    const [parsedPacketCount, setParsedPacketCount] = createSignal<number>(0);
    const [PacketStructureViewModels, setPacketStructureViewModels] = createStore<PacketStructureViewModel[]>([]);
    const [sendingLoopState, setSendingLoopState] = createSignal<SendingLoopState | null>(null);

    let unlistenFunctions: UnlistenFn[];

    onMount(async () => {
        // Listen to events generated by the Rust backend so that the view of the backend-managed state can be kept
        // up-to-date
        // Save the result of each listen call so that in the event that this component is unmounted the listeners
        // can be safely unregistered
        unlistenFunctions = [
            await listen<string>("error", ({payload: message}) => {
                // Log informative errors reported by the Rust backend for debugging purposes
                //console.error(message);
            }),
            await listen<SerialUpdateResult>("serial-update", ({payload: result}) => {
                //console.log(result);
                if (result.newAvailablePortNames) {
                    setAvailablePortNames(result.newAvailablePortNames);
                }
                if (result.parsedPackets) {
                    console.log(result.parsedPackets);
                    pushParsedPackets(result.parsedPackets);
                    setParsedPacketCount(parsedPacketCount() + result.parsedPackets.length);
                }
            }),
            await listen<PacketStructureViewModelUpdate[]>("packet-structures-update", event => {
                //console.log(event);

                for (const PacketStructureViewModelUpdate of event.payload) {
                    switch (PacketStructureViewModelUpdate.type) {
                        case PacketStructureViewModelUpdateType.CreateOrUpdate:
                            const PacketStructureViewModel = PacketStructureViewModelUpdate.data as PacketStructureViewModel;
                            if (PacketStructureViewModels.some(oldPacketStructureViewModel => oldPacketStructureViewModel.id === PacketStructureViewModel.id)) {
                                // Update the existing view model
                                setPacketStructureViewModels(
                                    oldPacketStructureViewModel => oldPacketStructureViewModel.id === PacketStructureViewModel.id,
                                    PacketStructureViewModel
                                );
                            } else {
                                // Add the new view model
                                setPacketStructureViewModels(
                                    PacketStructureViewModels.length,
                                    PacketStructureViewModel
                                );
                            }
                            break;
                        case PacketStructureViewModelUpdateType.Delete:
                            const deletedPacketStructureViewModelId = PacketStructureViewModelUpdate.data as number;
                            setPacketStructureViewModels(
                                PacketStructureViewModels.filter(PacketStructureViewModel => PacketStructureViewModel.id !== deletedPacketStructureViewModelId),
                            );
                            break;
                    }
                    
                }
            }),
            await listen<SendingLoopState>("sending-loop-update", ({payload}) => {
                setSendingLoopState(payload);
            })
        ];

        // Let the backend know that the frontend is ready to receive the initial "packet-structures-update" event
        // Note: the current Rust implementation also starts the background timer to read from the selected serial port
        await emit("initialized");
    });

    // TODO: remove once live telemetry is confirmed to work
    // Push test data to graphs once per second

    // setInterval(() => {

    //     const parsedPackets: Packet[] = [
    //         {fieldData: [Date.now(), 20, 30, 40], metaData: [], structureId: 0}
    //     ];

    //     pushParsedPackets(parsedPackets);
    //     setParsedPacketCount(parsedPacketCount() + parsedPackets.length);
    // }, 1000);

    onCleanup((): void => {
        // Unlisten to each of the events that were listened to when this component was mounted
        for (const unlistenFunction of unlistenFunctions) {
            unlistenFunction();
        }
    });

    const context = {
        availablePortNames: availablePortNames,
        parsedPacketCount: parsedPacketCount,
        PacketStructureViewModels: PacketStructureViewModels,
        setPacketStructureViewModels: setPacketStructureViewModels,
        sendingLoopState: sendingLoopState
    };

    return (
        <BackendContext.Provider value={context}>
            {props.children}
        </BackendContext.Provider>
    );
};

/**
 * Use the view into the backend-managed state provided by the {@link BackendContext}.
 *
 * @returns the current {@link BackendContextValue}
 */
export const useBackend = (): BackendContextValue => useContext(BackendContext);
